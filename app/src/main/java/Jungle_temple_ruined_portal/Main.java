/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package Jungle_temple_ruined_portal;

import kaptainwutax.biomeutils.Biome;
import kaptainwutax.biomeutils.source.OverworldBiomeSource;
import kaptainwutax.featureutils.structure.JunglePyramid;
import kaptainwutax.featureutils.structure.RuinedPortal;
import kaptainwutax.seedutils.lcg.rand.JRand;
import kaptainwutax.seedutils.mc.ChunkRand;
import kaptainwutax.seedutils.mc.MCVersion;
import kaptainwutax.seedutils.mc.pos.BPos;
import kaptainwutax.seedutils.mc.pos.CPos;
import kaptainwutax.seedutils.util.math.DistanceMetric;
import kaptainwutax.seedutils.util.math.Vec3i;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

public class Main {
        public static void main(String[] args) {
        ChunkRand chunkRand=new ChunkRand();

        // instantiate new objects of the jungle pyramid/ruined portal classes
        JunglePyramid junglePyramid=new JunglePyramid(MCVersion.v1_16_1);
        RuinedPortal ruinedPortal=new RuinedPortal(MCVersion.v1_16_1);

        ArrayList<Long> structureSeeds=new ArrayList<>();
        for (long structureSeed = 0; structureSeed < 1L << 48; structureSeed++) {

            // find the chunk positions of the two structures within the (0,0) region
            CPos jungle1 = junglePyramid.getInRegion(structureSeed, 0, 0, chunkRand);
            CPos portal1 = ruinedPortal.getInRegion(structureSeed, 0, 0, chunkRand);

            // check to see if these two structures are within 2 chunks of (0,0)
            if (jungle1.distanceTo(new Vec3i(0, 0, 0), DistanceMetric.EUCLIDEAN_SQ) > 2) continue;
            if (portal1.distanceTo(new Vec3i(0, 0, 0), DistanceMetric.EUCLIDEAN_SQ) > 2) continue;

            // if conditions are met, we mark this as a viable structure seed to be processed later for good world seeds
            structureSeeds.add(structureSeed);

            // we only need 100 structure seeds
            if (structureSeeds.size() > 100) {
                System.out.println("Structure Seeds Complete");
                break;
            }
        }

        for (long structureSeed : structureSeeds) {

            // get chunk positions once again, will be used to do biome check
            CPos jungle1 = junglePyramid.getInRegion(structureSeed, 0, 0, chunkRand);
            CPos portal1 = ruinedPortal.getInRegion(structureSeed, 0, 0, chunkRand);

            for (long biomeSeed = 0; biomeSeed < 1L << 16; biomeSeed++) {
                long worldSeed = biomeSeed<<48|structureSeed;
                OverworldBiomeSource overworldBiomeSource=new OverworldBiomeSource(MCVersion.v1_16_1, worldSeed);

                // make sure the structures can spawn w/ correct biome
                if (!junglePyramid.canSpawn(jungle1.getX(), jungle1.getZ(), overworldBiomeSource)) continue;
                if (!ruinedPortal.canSpawn(portal1.getX(), portal1.getZ(), overworldBiomeSource)) continue;

                // spawn point check
                double spawnDist = overworldBiomeSource.getSpawnPoint().distanceTo(new Vec3i(0, 0, 0), DistanceMetric.EUCLIDEAN);
                if (spawnDist > 64) {
                    continue;
                }

                System.out.println(worldSeed);
                break;

            }
        }
    }
}
